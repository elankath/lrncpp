= C++ Notes
Tarun Elankath <dev@elankath.com>
Version 0.2, 2020-11-20
:toc:
C++ Notes

== Strings

=== Use zstring and czstring for C-style,zero-terminated strings.
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#f25-use-a-zstring-or-a-not_nullzstring-to-designate-a-c-style-string
C-style strings are ubiquitous. They are defined by convention: zero-terminated arrays of characters. We must distinguish C-style strings from a pointer to a single character or an old-fashioned pointer to an array of characters.
If you don't need null termination, use string_view.

[source,cpp]
----
/* When I call length(s) should I check if s is nullptr first?
 Should the implementation of length() check if p is nullptr? */
int length(const char* p);

// the implementor of length() must assume that p == nullptr is possible
int length(zstring p);

// it is the caller's job to make sure p != nullptr
int length(not_null<zstring> p);
----


== Pointers, Ownership
=== GSL owner
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t
[source,cpp]
----
X* compute(args)    // don't
{
    X* res = new X{};
    // ...
    return res; // Who deletes the returned X
}
owner<X*> compute(args)    // It is now clear that ownership is transferred
{
// This tells analysis tools that res is an owner. That is, its value must be deleted or transferred to another owner, as is done here by the return.
    owner<X*> res = new X{};
    // ...
    return res;
}
----

=== not_null
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i12-declare-a-pointer-that-must-not-be-null-as-not_null
[source,cpp]
----
int length(const char* p);            // it is not clear whether length(nullptr) is valid
length(nullptr);                      // OK?
int length(not_null<const char*> p);  // better: we can assume that p cannot be nullptr
int length(const char* p);            // we must assume that p can be nullptr
----

=== Pointers and References
==== For general use, take T* or T& arguments rather than smart pointers
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#f7-for-general-use-take-t-or-t-arguments-rather-than-smart-pointers

Passing a smart pointer transfers or shares ownership and should only be used when ownership semantics are intended.
A function that does not manipulate lifetime should take raw pointers or references instead.

Obviously don't T* and T& to async functions, ie lifetime of pointer should be valid.

[source,cpp]
----
// accepts any int*
void f(int*);

// can only accept ints for which you want to transfer ownership
void g(unique_ptr<int>);

// can only accept ints for which you are willing to share ownership
void g(shared_ptr<int>);

// doesn't change ownership, but requires a particular ownership of the caller
void h(const unique_ptr<int>&);

// accepts any int
void h(int&);
----

==== Prefer T* over T& when "no argument" is a valid option
A pointer (T*) can be a nullptr and a reference (T&) cannot, there is no valid "null reference".
Sometimes having nullptr as an alternative to indicated "no object" is useful, but if it is not, a reference is notationally simpler and might yield better code.

[source,cpp]
----
string zstring_to_string(zstring p) // zstring is a char*; that is a C-style string
{
    if (!p) return string{};    // p might be nullptr; remember to check
    return string{p};
}

void print(const vector<int>& r)
{
    // r refers to a vector<int>; no check needed
}
----
==== Return a T* to indicate a position (only)
That's what pointers are good for. Returning a T* to transfer ownership is a misuse.
*Note* Do NOT return a pointer to something that is not in the caller's scope

[source,cpp]
----
Node* find(Node* t, const string& s)  // find s in a binary tree of Nodes
{
    if (!t || t->name == s) return t;
    if ((auto p = find(t->left, s))) return p;
    if ((auto p = find(t->right, s))) return p;
    return nullptr; // possibly better to use std::optional ?
}
----


=== std::unique_ptr

Use a unique_ptr<T> to transfer ownership where a pointer is needed
Using unique_ptr is the cheapest way to pass a pointer safely.
[source,cpp]
----
unique_ptr<Shape> get_shape(istream& is)  // assemble shape from input stream
{
    auto kind = read_header(is); // read header and identify the next shape on input
    switch (kind) {
    case shape_constants.circle:
        return make_unique<Circle>(is);
    case shape_constants.triangle:
        return make_unique<Triangle>(is);
    // ...
    }
}
----

== Functions

=== Function Parameters

==== Function Parameters should be strongly typed
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i4-make-interfaces-precisely-and-strongly-typed

[source,cpp]
----
draw_rect(100, 200, 100, 500); // BAD: what do the numbers specify?
draw_rect(p.x, p.y, 10, 20); // BAD: what units are 10 and 20 in?

void draw_rectangle(Point top_left, Point bottom_right);
void draw_rectangle(Point top_left, Size height_width);

draw_rectangle(p, Point{10, 20});  // GOOD: two corners
draw_rectangle(p, Size{10, 20});   // GOOD: one corner and a (height, width) pair

set_settings(true, false, 42); // BAD: what do the numbers specify?

alarm_settings s{}; //GOOD: safe and legible.
s.enabled = true;
s.displayMode = alarm_settings::mode::spinning_light;
s.frequency = alarm_settings::every_10_seconds;
set_settings(s);

//For the case of a set of boolean values consider using a flags enum; a pattern that expresses a set of boolean values.
enable_lamp_options(lamp_option::on | lamp_option::animate_state_transitions);


// In the following example, it is not clear from the interface what time_to_blink means: Seconds? Milliseconds?

void blink_led(int time_to_blink) // bad -- the unit is ambiguous
{
    // ...
    // do something with time_to_blink
    // ...
}
void use()
{
    blink_led(2);
}
// std::chrono::duration types helps making the unit of time duration explicit.
void blink_led(milliseconds time_to_blink) // good -- the unit is explicit
{
    // ...
    // do something with time_to_blink
    // ...
}
void use()
{
    blink_led(1500ms);
}
template<class rep, class period>
void blink_led(duration<rep, period> time_to_blink) // good -- accepts any unit
{
    // assuming that millisecond is the smallest relevant unit
    auto milliseconds_to_blink = duration_cast<milliseconds>(time_to_blink);
    // ...
    // do something with milliseconds_to_blink
    // ...
}

void use()
{
    blink_led(2s);
    blink_led(1500ms);
}
----

==== Avoid too many parameters
Define a struct as the parameter type and name the fields for those parameters accordingly:
[source,cpp]
----
struct SystemParams {
    string config_file;
    string output_path;
    seconds timeout;
};
void initialize(SystemParams p);
----

==== Parameter Passing
See link:cpp_param_ref.pdf[CPP Param]

==== Leverage Pre Conditions and Post Conditions
[source,cpp]
----
double sqrt(double x) { Expects(x >= 0); /* ... */ }
int area(int height, int width) {
    Expects(height > 0 && width > 0);            // good
}
int area(int height, int width)
{
    auto res = height * width;
    Ensures(res > 0);
    return res;
}
// Famous security bug
void f()    // PROBLEMATIC
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, sizeof(buffer)); //optimizer eliminated the apparently redundant memset() call:
}
void f()    // BETTER
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, sizeof(buffer));
    Ensures(buffer[0] == 0);
}
----

=== Default Arguments

==== Where there is a choice, prefer default arguments over overloading
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#f51-where-there-is-a-choice-prefer-default-arguments-over-overloading

[source,cpp]
----
void print(const string& s, format f = {});
// ABOVE is BETTER than BELOW
void print(const string& s);  // use default format
void print(const string& s, format f);

----
==== Do not provide different default arguments for a virtual function and an overrider
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c140-do-not-provide-different-default-arguments-for-a-virtual-function-and-an-overrider

[source,cpp]
----
class Base {
public:
    virtual int multiply(int value, int factor = 2) = 0;
    virtual ~Base() = default;
};
class Derived : public Base {
public:
    int multiply(int value, int factor = 10) override;
};
Derived d;
Base& b = d;
b.multiply(10);  // these two calls will call the same function but
d.multiply(10);  // with different arguments and so different results
----



=== Leverage typedefs and using
[source,cpp]
----
class Date {
public:
    Month month() const;  // do
    int month();          // don't
    // ...
};
----

=== std::find Examples
[source,cpp]
----
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    auto p = find(begin(v), end(v), val);  // better
    // ...
}
----


== Classes

https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c2-use-class-if-the-class-has-an-invariant-use-struct-if-the-data-members-can-vary-independently

* Use class if the class has an invariant; use struct if the data members can vary independently0
* Use class rather than struct if any member is non-public
* Ensure that a copyable (value type) class has a default constructor
* Prefer default constructors to be simple and non-throwing
* Prefer in-class initializers to member initializers in constructors for constant initializers
* Prefer initialization to assignment in constructors
* Define and initialize member variables in the order of member declaration
* Don’t define a default constructor that only initializes data members; use in-class member initializers instead.
Using in-class member initializers lets the compiler generate the function for you.
The compiler-generated function can be more efficient.
* Use delegating constructors to represent common actions for all constructors of a class
* Use a conventional class member declaration order. When declaring a class use the following order:
 ** types: classes, enums, and aliases (using)
 ** constructors, assignments, destructor
 ** functions
 ** data
 ** Use `public` before `protected` before `private` order.



[source,cpp]
----
struct Pair {  // the members can vary independently
    string name;
    int volume;
};
class Date {
public:
    // validate that {yy, mm, dd} is a valid date and initialize
    Date(int yy, Month mm, char dd);
    // ...
    int day() const;
    Month month() const;
private:
    int dd = 1;
    int mm = 1;
    int yyyy = 1970;
};
class A {   // Good
    string s1;
public:
    A(czstring p) : s1{p} { } // GOOD: directly construct (and the C-string is explicitly named)
    // ...
};
class D {   // Best
    string s1;
public:
    D(string_view v) : s1{v} { } // GOOD: directly construct
    // ...
};

class Date2 {
    int d;
    Month m;
    int y;
public:
    Date2(int dd, Month mm, year yy)
        :d{dd}, m{mm}, y{yy}
        { if (!valid(d, m, y)) throw Bad_date{}; }

    Date2(int dd, Month mm)
        :Date2{dd, mm, current_year()} {}
    // ...
};
// If the “repeated action” is a simple initialization, conside an in-class member initializer.
----

=== Abstract Classes

====  Prefer pure abstract classes as interfaces to class hierarchies
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i25-prefer-abstract-classes-as-interfaces-to-class-hierarchies

[source,cpp]
----
class Shape {    // better: Shape is a pure interface
public:
    virtual Point center() const = 0;   // pure virtual functions
    virtual void draw() const = 0;
    virtual void rotate(int) = 0;
    // ...
    // ... NO DATA MEMBERS ...
    // ...
    virtual ~Shape() = default;
};
----

== Lambdas

=== Capture by Reference for Local Lambdas
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#f52-prefer-capturing-by-reference-in-lambdas-that-will-be-used-locally-including-passed-to-algorithms

Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms

[source,cpp]
----
// Here, a large object (a network message) is passed to an iterative algorithm,
// and is it not efficient or correct to copy the message (which might not be copyable):
std::for_each(begin(sockets), end(sockets), [&message](auto& socket)
{
    socket.send(message);
});

/*
This is a simple three-stage parallel pipeline.
Ea$h stage object encapsulates a worker thread and a queue, has a process function to enqueue work.
It's destructor automatically blocks waiting for the queue to empty before ending the thread.
*/
void send_packets(buffers& bufs)
{
    stage encryptor([](buffer& b) { encrypt(b); });
    stage compressor([&](buffer& b) { compress(b); encryptor.process(b); });
    stage decorator([&](buffer& b) { decorate(b); compressor.process(b); });
    for (auto& b : bufs) { decorator.process(b); }
}  // automatically blocks waiting for pipeline to finish

----
=== Capture by value for Non-Local Lambdas

https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#f53-avoid-capturing-by-reference-in-lambdas-that-will-be-used-non-locally-including-returned-stored-on-the-heap-or-passed-to-another-thread

Pointers and references to locals shouldn't outlive their scope.
Lambdas that capture by reference are just another place to store a reference to a local object,
and shouldn't do so if they (or a copy) outlive the scope.

[source,cpp]
----
int local = 42;
// Want a reference to local.
// Note, that after program exits this scope,
// local no longer exists, therefore
// process() call will have undefined behavior!
thread_pool.queue_work([&] { process(local); }); // BAD !!
thread_pool.queue_work([=] { process(local); }); // GOOD
----

=== If you capture this, capture all variables explicitly (no default capture)

It's confusing. Writing [=] in a member function appears to capture by value, but actually
captures data members by reference because it actually captures the invisible this pointer
by value. If you meant to do that, write this explicitly.

[source,cpp]
----
class my_class {
    int x = 0;
    // ...
    void f() {
        int i = 0;
        // ...
        auto lambda = [=] { use(i, x); };   // BAD: "looks like" copy/value capture
        // [&] has identical semantics and copies the this pointer under the current rules
        // [=,this] and [&,this] are not much better, and confusing
        x = 42;
        lambda(); // calls use(0, 42);
        x = 43;
        lambda(); // calls use(0, 43);
        // ...
        auto lambda2 = [i, this] { use(i, x); }; // ok, most explicit and least confusing
        // ...
    }
};
----





== Utilities
=== std::span

https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#p7-catch-run-time-errors-early
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i13-do-not-pass-an-array-as-a-single-pointer
[source,cpp]
----
void increment1(int* p, int n)    // bad: error-prone
{
    for (int i = 0; i < n; ++i) ++p[i];
}
void increment2(span<int> p)
{
    for (int& x : p) ++x;
}
void use1(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment1(a, m);   // maybe typo, maybe m <= n is supposed
                        // but assume that m == 20
    // ...
}
void use2(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment2({a, m});    // maybe typo, maybe m <= n is supposed
    // ...
}
// Now, m < = n can be checked at the point of call (early) rather than later.
// If all we had was a typo so that we meant to use n as the bound, the code could be further simplified (eliminating the possibility of an error):
void use3(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment2(a);   // the number of elements of a need not be repeated
    // ...
}

----
[source,cpp]
----
void copy_n(const T* p, T* q, int n); // copy from [p:p+n) to [q:q+n)
----

What if there are fewer than `n` elements in the array pointed to by `q`?
Then, we overwrite some probably unrelated memory.
What if there are fewer than n elements in the array pointed to by `p`?
Then, we read some probably unrelated memory. Either is undefined behavior and a potentially very nasty bug.

== Design Patterns

=== Singletons

=== Use static for singletons
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i3-avoid-singletons

[source,cpp]
----
X& myX()
{
    static X my_x {3};
    return my_x;
}
----

=== Pimpl
=== std::call_once
https://en.cppreference.com/w/cpp/thread/call_once

https://stackoverflow.com/a/19992704/120959
[source,cpp]
----
void g() {
 static std::once_flag flag2;
 std::call_once(flag2, initializer());
}
----




